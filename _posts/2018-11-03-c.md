---
title: Заметки по книге - Си
tags: [books, c]
reference:

---

* TOC 
{:toc}

# Упражнения

Упражнение 1.3. Модифицируйте программу преобразования температур так, чтобы она выводила заголовок над таблицей.
<details>
<pre><code class="c">int main (){
    float fahr, celsius;
    int lower, upper, step;

    lower = 0;      // нижняя граница температур
    upper = 300;    // верняя граница температур
    step = 20;      // величина шага

    printf("%s  %s\n", "Фаренгейт", "Цельсию");

    while ( fahr <= upper ){
        celsius = (5.0/9.0) * (fahr - 32.0); // c = (5/9)(f - 32)
        printf("%9.0f %6.2f\n", fahr, celsius);
        fahr = fahr + step;
    }

    return 0;
}

$ fat.c
...
Фаренгейт  Цельсию
        0 -17.78
       20  -6.67
       40   4.44
...
</code></pre>
</details><br>

Упражнение 1.5. Доработайте программу преобразования температур так, чтобы она выводила таблицу в обратном порядке, т.е. от 300 градусов до нуля

<details>
<pre><code class="c">$ cat cel.c

int main (){
    float fahr, celsius = 0;
    int lower, upper, step;

    lower = 0;      // нижняя граница температур
    upper = 100;    // верняя граница температур
    step = 20;      // величина шага

    while ( celsius <= upper ){
        fahr = (celsius * (9.0/5.0)) + 32;
        printf("%3.0f %6.2f\n", celsius, fahr);
        celsius += step;
    }

    return 0;
}

$ ./a.out
...
  0  32.00
 20  68.00
 40 104.00
 60 140.00
 80 176.00
100 212.00
...
</code></pre>    
</details><br>

Упражнение 1.6. Проверьте, что выражение getchar() != EOF действительно равно 1 или 0;

Упражнение 1.7. Напишите программу вывода значения константы EOF
Упражнение 1.8. Напишите программу для подчета пробелов, знаков табуляции и символов конца строки

Упражнение 1.9. Напишите программу для копирования входного потока в выходной с заменой строки состоящей из одного или нескольких пробелов, одним пробелом

Упражнение 1.10. Напишите программу для копирования входного потока в выходной с заменой знаков табуляции \t, символа знака назад (backspace) на \b, а косую четрту на \\.

Упражнение 1.12. Напишите программу для вывода входного потока по одному слову в строке

Упражнение 1.13. Напишите программу для вывода гистограммы длин слов во входном потоке. Построить гистограмму с горизонтальными рядами довольно легко, а вот с вертивальными столбцами труднее.

Упражнение 1.14. Напишите программу для вывода гистограммы частот, с которыми встречаются во входном потоке различные символы.

Упражнение 1.15. Перепешите программу преобразования температур, чтобы само преобразование выполнялось функцией

Упражнение 1.16. Доработайте главный модуль программы, определения самой длинной строки так, чтобы она выводила правильное значение для какой угодно длины строк входного потока, на сколько это позволяет текст

Упражнение 1.17. Напишите программу для вывода всех строк входного потока, имеющих длину более 80 символов

Упражнение 1.18. Напишите программу для удаления лишних пробелов и табуляций в хвосте каждой поступающей строки входного потка, которая бы также удаляла полностью пустые строки

Упражнение 1.19. Напишите функцию reverse(str), которая переписывает свой строковый аргумент str в обратном порядке.

Упражнение 1.20. Напишите программу detab, которая бы заменяла символы табуляции во входном потоке соответствующим кол-вом пробелов до следующий границы табуляции.

Упражнение 1.21. Напишите программу entab, которая заменяла пустые строки, состоящие из одних пробелов, строками, содержащими минимальное кол-во табуляций и дополнительных пробелов - так чтобы заполнять то же пространство. Используйте те же параметры табуляции, что и в программе detab. Если для заполнения места до следующей границы табуляции требуется один пробел или один символ табуляции, то что следует предпочесть?

Упражнение 1.22. Напишите программу для сворачивания слишком длинных строк входного потока в две или более короткие строки после последнего не пустого символа, встречающийся после n-ым столбцом длинной строки. Постарайтесь, чтобы ваша программа обрабатывала очень длинные строки корректно, а также удаляла лишние пробелы и табуляции перед указанным столбцом.

Упражнение 1.23. Напишите программу для удаления всех комментариев из программы на C. Позаботьтесь о корректной обработке символьных констант и строк в двойных кавычках. Вложенные комментарии в C не допускаются

Упражнение 1.24. Напишите программу для выполнения примитивной синтаксической проверки программ на C, такие как непарные круглые, квадратные и фигурные скобки. Незабудь о одинарных и двойных кавычках, управляющих символах и комментариях.

Упражнение 2.1. Напишите программу для определения диапазонов переменных типов char, short, int и long (как signed так и unsigned), путем вывода соответствующих значений из заголовочных файлов, а также с помощью непостредственного вычисления.

Упражнение 2.2. Напишите цикл эквивалентный, не используя операции && и \|\|

Упражнение 2.3. Напишите функцию htoi(s), которая преобразует строку шестьнадцатеричных цифр (учитывая необязательные элементы 0x или 0X) в ее целочисленный эквивалент. В число допустимых цифр входят десятичные цифры от 0 до 9, а также буквы a-f и A-F.

<details>
<pre><code class="c">int htoi(char []);

int main(){

    char str[] = "0xabcdef0";

    if (0){ // debug
        int number = (int)strtol(str, NULL, 16);
        int res = htoi(str);
        printf("result = %d; number = %d\n", res, number);
    } else {
        int res = htoi(str);
        printf("Исходная строка = '%s'; целое число = %d\n", str, res);
    }
    
    return 0;
}

// преобразует строку шестьнадцатеричных цифр в целое число
int htoi(char s[]){
    int i, n = 0;

    if ( !(s[0] == '0' && ( s[1] == 'x' || s[1] == 'X')) )
        return 0;

    for ( i = 2; s[i] != '\0'; i++ ){
        if ( s[i] >= '0' && s[i] <= '9' ){
            n = n * 16 + ( s[i] - '0' );
        } else if (( s[i] >= 'a' && s[i] <= 'f' ) ){
            n = n * 16 + ( s[i] - 'a' + 10);
        } else if ( s[i] >= 'A' && s[i] <= 'F' ){
            n = n * 16 + ( s[i] - 'A' + 10);
        }
    }

    return n;
}

...
Исходная строка = '0xabcdef0'; целое число = 180150000
[Finished in 0.1s]
...
</code></pre>
</details>
<br>


# Глава 1. Вводный курс

<pre><code class="c">$ cat hello.c
#include <stdio.h\>

int main (){
    printf("hello, world!\n");
    return 0;
}

$ cc hello.c
$ ./a.out 
hello, world!
</code></pre>

<pre><code class="c">$ cat fat.c
#include <stdio.h\>

// Вывод таблицы температур по Фаренгейту и Цельсию

int main (){
    float fahr, celsius;
    int lower, upper, step;

    lower = 0;      // нижняя граница температур
    upper = 300;    // верняя граница температур
    step = 20;      // величина шага

    while ( fahr <= upper ){
        celsius = (5.0/9.0) * (fahr - 32.0); // c = (5/9)(f - 32)
        printf("%3.0f %6.2f\n", fahr, celsius);
        fahr = fahr + step;
    }

    return 0;
}

$ ./a.out 
...
  0 -17.78
 20  -6.67
 40   4.44
 60  15.56
 80  26.67
100  37.78
120  48.89
140  60.00
160  71.11
180  82.22
200  93.33
220 104.44
240 115.56
260 126.67
280 137.78
300 148.89
...
</code></pre>

* %3.0f - вывести вещественое число в поле шириной не менее 3 символа без десятичной части
* %6.2f - вывести вещественое число в поле шириной не менее 6 символа и вывод двух цифр после точки

<pre><code class="c">$ cat fatv2.c

// Вывод таблицы температур по Фаренгейту и Цельсию (v2)
int main (){
    float fahr;

    for ( fahr = 0; fahr <= 300; fahr += 20 )
        printf("%3.0f %6.2f\n", fahr, (5.0/9.0)*(fahr-32));

    return 0;
}

$ ./a.out
...
  0 -17.78
 20  -6.67
 40   4.44
 60  15.56
 80  26.67
100  37.78
...
</code></pre>

Упражнение 1.5. Доработайте программу преобразования температур так, чтобы она выводила таблицу в обратном порядке, т.е. от 300 градусов до нуля

<pre><code class="c">$ cat fatv3.c

// Вывод таблицы температур по Фаренгейту и Цельсию (v3)
int main (){
    float fahr;

    for ( fahr = 300; fahr >= 0; fahr -= 20 )
        printf("%3.0f %6.2f\n", fahr, (5.0/9.0)*(fahr-32));

    return 0;
}


$ ./a.out
...
300 148.89
280 137.78
260 126.67
240 115.56
220 104.44
200  93.33
...
</code></pre>

<pre><code class="c">$ cat fatv4.c

#define LOWER 0
#define UPPER 300
#define STEP 20

// Вывод таблицы температур по Фаренгейту и Цельсию (v4)
int main (){
    float fahr;

    for ( fahr = LOWER; fahr <= UPPER; fahr += STEP )
        printf("%3.0f %6.2f\n", fahr, (5.0/9.0)*(fahr-32));

    return 0;
}


$ ./a.out
...
  0 -17.78
 20  -6.67
 40   4.44
 60  15.56
 80  26.67
100  37.78
...
</code></pre>

## 1.5.1 Копирование файлов

<pre><code class="с">$ cat get-putchar.c

// копирование входного потока в выходной
int main(){
    char c;
    
    while ( (c = getchar()) != EOF )
        putchar(c);

    return 0;
}

$ ./a.out 
...
1
1
2
2
g
g
...
</code></pre>

Упражнение 1.6. Проверьте, что выражение getchar() != EOF действительно равно 1 или 0;

<pre><code class="c">    while ( (c = getchar()) != EOF ){
        printf("%d\n", getchar() != EOF);
        putchar(c);
    }

$ ./a.out 
...
e
1
eq
1
qd
1
...
</code></pre>

PS. В конце файла EOF будет 1 т.е. true

Упражнение 1.7. Напишите программу вывода значения константы EOF

<pre><code class="c">int main(){
    printf("%d\n", EOF);
    printf("%d\n", getchar());
    return 0;
}

$ ./a.out
...
-1
1
49
...
</code></pre>

## 1.5.2 Подсчет символов

<pre><code class="c">$ cat count_char.c

// подсчет кол-ва символов в входном потоке
int main(){

    long count = 0;
    while ( getchar() != EOF )
        ++count;
    printf("%ld", count);

    return 0;
}

$ ./a.out 
...
1
2
3
4
...
</code></pre>

PS символ перевода строки тоже считается

## 1.5.2 Подсчет строк

<pre><code class="c">$ cat count_str.c

// подсчет кол-ва строк в входном потоке
int main(){

    long count = 0;
    char c;

    while ( (c = getchar()) != EOF )
        if ( c == '\n' )
            ++count;

    printf("%ld\n", count);

    return 0;
}

$ ./a.out 
...
hello 
world
2
...
</code></pre>

Упражнение 1.8. Напишите программу для подчета пробелов, знаков табуляции и символов конца строки

<pre><code class="c">$ cat count_spaces.c

// подсчет кол-ва пробелов, знаков табуляции и символов конца строки
int main(){

    long count_spaces = 0, count_tabs = 0, count_endstr = 0;
    char c;

    while ( (c = getchar()) != EOF )
        if ( c == ' ' ){
            ++count_spaces;
        } else if ( c == '\t' ){
            ++count_tabs;
        } else if ( c == '\0' ){
            ++count_endstr;
        }

    printf("Кол-во пробелов = %ld; Кол-во табуляций = %ld; Кол-во символов конца строки = %ld\n", count_spaces, count_tabs, count_endstr);

    return 0;
}

...
$ ./a.out 
dsa
    
e
 
 dsa
Кол-во пробелов = 2; Кол-во табуляций = 1; Кол-во символов конца строки 0
...
</code></pre>

Упражнение 1.9. Напишите программу для копирования входного потока в выходной с заменой строки состоящей из одного или нескольких пробелов, одним пробелом

<pre><code class="c">$ cat replace_spaces.c

int main(){

    int is_last_char_space = 0;
    char c;
    while ( (c = getchar()) != EOF ){
        if ( c == ' ' ){
            if ( !is_last_char_space ) putchar(' ');
            is_last_char_space = 1;
        } else {
            putchar(c);
            is_last_char_space = 0;
        }
    }

    return 0;
}

$ ./a.out 
...
help   mee   
help mee 
help mee   mm  ee  
help mee mm ee 
...
</code></pre>

Упражнение 1.10. Напишите программу для копирования входного потока в выходной с заменой знаков табуляции \t, символа знака назад (backspace) на \b, а косую четрту на \\.

<pre><code class="c">$ cat replace_symbols.c

int main(){

    char c;
    while ( (c = getchar()) != EOF ){
        if ( c == '\t' ){
            printf("\\t");
        } else if (c == '\b'){
            printf("\\b");
        } else if (c == '\\'){
            printf("\\\\");
        } else {
            putchar(c);
        }
    }

    return 0;
}

$ ./a.out 
...
test    help    me \
test\thelp\tme \\
...
</code></pre>

## 1.5.4 Подсчет строк

<pre><code class="c">$ cat count_words.c

#define IN 1
#define OUT 0

// подсчет строк, слов, и символов во входном потоке

int main(){

    int count_lines, count_words, count_chars, state;
    char c;

    state = OUT;
    count_lines = count_words = count_chars = 0;

    while ( (c = getchar()) != EOF ){
        ++count_chars;
        if ( c == '\n' ) ++count_lines;
        if ( c == ' ' || c == '\n' || c == '\t' ){
            state = OUT;
        } else if ( state == OUT ){
            state = IN;
            ++count_words;
        }
    }

    printf("%d %d %d\n", count_lines, count_words, count_chars);

    return 0;
}


$ wc input.txt 
...
  5  69 446 input.txt
...
$ ./a.out < input.txt 
...
5 69 446
...
</code></pre>

Упражнение 1.12. Напишите программу для вывода входного потока по одному слову в строке

<pre><code class="c">$ cat print_in_new_line.c

int main(){

    char c;

    while ( (c = getchar()) != EOF )
        if ( c != '\n' ) printf("%c\n", c);

    return 0;
}

$ ./a.out 
...
help
h
e
l
p
hello
h
e
l
l
o
^C
...
</code></pre>

## 1.6 Массивы

<pre><code class="c">$ cat count_digits.c

// подсчет кол-ва цифр, пробелов, и остальных
int main(){

    int i, count_spaces, count_other;
    char c;
    int ndigit[10];

    count_spaces = count_other = 0;
    for (int i = 0; i < 10; ++i)
        ndigit[i] = 0;

    while ( (c = getchar()) != EOF ){
        if ( c >= '0' && c <= '9' )
            ++ndigit[c - '0'];
        else if ( c == ' ' || c == '\n' || c == '\t' )
            ++count_spaces;
        else
            ++count_other;
    }

    printf("digits = ");
    for (int i = 0; i < 10; ++i)
        printf(" %d", ndigit[i]);

    printf(", spaces = %d, other = %d\n", count_spaces, count_other);

    return 0;
}

$ ./a.out < count_digits.c 
...
digits =  10 3 0 0 0 0 0 0 0 1, spaces = 231, other = 447
...
</code></pre>

Упражнение 1.13. Напишите программу для вывода гистограммы длин слов во входном потоке. Построить гистограмму с горизонтальными рядами довольно легко, а вот с вертивальными столбцами труднее.

<pre><code class="c">$ cat print_histogram.v1.c

#define IN 1
#define OUT 1

int main(){

    int i, j, state, count = 0;
    char c;
    int words[100];// = {0, 1, 13, 5, 9, 12, 7, 9, 3, 5};

    state = OUT;

    for (int i = 0; i < 10; ++i)
        words[i] = 0;

    while ( (c = getchar()) != EOF ){

        if ( c == ' ' || c == '\n' || c == '\t' ){
            state = OUT;
            ++words[count];
            count = 0;
        } else if ( state == OUT ){
            state = IN;
            ++count;
        }
    }

    ++words[count];

    for (int i = 1; i < 10; ++i){
        printf("%d", i);
        for (j = 0; j < words[i]; j++)
            putchar('-');
        putchar('\n');
    }

    return 0;
}

$ ./a.out < input.txt 
...
1-
2-------------
3-----
4---------
5------------
6-------
7---------
8---
9-----
...
$ ./a.out < cel.c 
...
1----------
2----------
3-----
4-----
5--------
6----
7---
8----
9--
...
</code></pre>


Упражнение 1.14. Напишите программу для вывода гистограммы частот, с которыми встречаются во входном потоке различные символы.

<pre><code class="c">$ cat print_histogram.v3.c
#define N 1000

void print_result(char [], int);

int main(){

    char chars[N], c;

    for (int i = 0; i < N; i++) chars[i] = 0;

    while ( (c = getchar()) != EOF )
        ++chars[c];

    print_result(chars, N);

    return 0;
}

void print_result(char arr[], int n){

    for (int i = 0; i < n; i++)
        if ( arr[i] ){
            printf("%c", i);
            for (int j = 0; j < arr[i]; j++)
                putchar('-');
            putchar('\n');
        }
}

$ ./a.out < print_histogram.v3.c 
...
----------------------------
 
!-
"--
#--
%-
'----
(--------------
)--------------
+--------
,-----
--
.-
0--------
1-
;---------------
<----
...
</code></pre>

## 1.7 Функции

<pre><code class="c">$ cat power.c

int power (int, int);

// тестирование power - функции возведения в степень
int main (){

    for(int i = 0; i < 10; i++)
        printf("%d %d %d\n", i, power(2, i), power(-3, i));

    return 0;
}

// power: возводит base в n-ую степень; n >= 0
int power (int base, int n){
    int p = 1;
    for (int i = 1; i <= n; i++)
        p *= base;
    return p;
}

$ ./a.out
...
0 1 1
1 2 -3
2 4 9
3 8 -27
4 16 81
5 32 -243
6 64 729
7 128 -2187
8 256 6561
9 512 -19683
...
</code></pre>

Упражнение 1.15. Перепешите программу преобразования температур, чтобы само преобразование выполнялось функцией

<pre><code class="c">cat fatv5.c

#define LOWER 0
#define UPPER 300
#define STEP 20

float celsius(float);

// Вывод таблицы температур по Фаренгейту и Цельсию (v5)
int main (){
    float fahr;

    for ( fahr = LOWER; fahr <= UPPER; fahr += STEP )
        printf("%3.0f %6.2f\n", fahr, celsius(fahr));

    return 0;
}

float celsius(float fahr){
    return (5.0/9.0)*(fahr-32);
}
</code></pre>

## 1.9 Массив символов

<pre><code class="c">$ cat longest-str.c

#define N 1000

int get_line(char [], int);
void copy(char [], char []);

int main(){

    int len, max = 0;
    char line[N], longest[N];

    while ((len = get_line(line, N)) > 0 ){
        if ( len > max ){
            max = len;
            copy(line, longest);
        }
    }

    if ( max > 0 )
        printf("%s", longest);
    return 0;
}

int get_line(char str[], int lim){
    int c, i;

    for (i = 0; i <= lim-1 && (c = getchar()) != EOF && c != '\n'; i++ )
        str[i] = c;

    if ( c == '\n' )
        str[i++] = c;

    str[i] = '\0';
    return i;
}

void copy(char from[], char to[]){
    int i = 0;
    while ((to[i] = from[i]) != '\0') i++;
}

$ ./a.out < longest-str.c 
...
    for (i = 0; i <= lim-1 && (c = getchar()) != EOF && c != '\n'; i++ )
...
</code></pre>

Упражнение 1.16. Доработайте главный модуль программы, определения самой длинной строки так, чтобы она выводила правильное значение для какой угодно длины строк входного потока, на сколько это позволяет текст

???

Упражнение 1.17. Напишите программу для вывода всех строк входного потока, имеющих длину более 80 символов

<pre><code class="c">$ cat longest-80-characters.c

#define N 1000
#define MAX_LEN 80

int get_line(char [], int);
void copy(char from[], char to[]);

int main(){

    int len, count = 0;
    char line[N], str[N][N];

    while ( ( len = get_line(line, N) ) > 0 ){
        if ( len >= MAX_LEN ){
            copy( line, str[count++] );
        }
    }

    for (int i = 0; i < count; ++i){
        printf("%s", str[i]);
    }

    return 0;
}

int get_line(char str[], int lim){

    int c, i;
    for (i = 0; i <= lim-1 && (c = getchar()) != EOF && c != '\n'; i++ ) str[i] = c;

    if ( c == '\n' ) str[i++] = c;
    str[i] = '\0';
    return i;
}

void copy(char from[], char to[]){
    int i = 0;
    while( ( to[i] = from[i] ) != '0' ) i++;
}

$ ./a.out < longest-80-characters.c
...
    for (i = 0
...
</code></pre>

Упражнение 1.18. Напишите программу для удаления лишних пробелов и табуляций в хвосте каждой поступающей строки входного потка, которая бы также удаляла полностью пустые строки

Упражнение 1.19. Напишите функцию reverse(str), которая переписывает свой строковый аргумент str в обратном порядке.

## 1.10 Внешние переменные

<pre><code class="c">$ cat longest-str.v2.c
#define N 1000

int max = 0;
char line[N], longest[N];

int get_line(void);
void copy(void);

// Вывод самой длинной строки. спец версия
int main(){

    int len;
    extern int max;
    extern char longest[];

    while ((len = get_line()) > 0 ){
        if ( len > max ){
            max = len;
            copy();
        }
    }

    if ( max > 0 )
        printf("%s", longest);
    return 0;
}

int get_line(void){
    int c, i;
    extern char line[];

    for (i = 0; i <= N-1 && (c = getchar()) != EOF && c != '\n'; i++ )
        line[i] = c;

    if ( c == '\n' )
        line[i++] = c;

    line[i] = '\0';
    return i;
}

void copy(void){
    int i = 0;
    extern char line[], longest[];
    while ((longest[i] = line[i]) != '\0') i++;
}

$ ./a.out < longest-str.v2.c
...
// Вывод самой длинной строки. спец версия
...
</code></pre>

<div class="error"><p>Использование глобальных переменных оочень плохо!</p></div>

Упражнение 1.20. Напишите программу detab, которая бы заменяла символы табуляции во входном потоке соответствующим кол-вом пробелов до следующий границы табуляции.

<pre><code class="c"> $cat 1.20.change_tabs.c
#define N 100
#define COUNT_TABS 4

int main(){

    char str[N];
    char c;
    int need_tabs = 0;

    while ((c = getchar()) != EOF){

        if ( c == '\t' ){
            if ( !need_tabs ){
                need_tabs = 1;
                for (int i = 0; i < COUNT_TABS; i++){
                    putchar(' ');
                }
            } else {
                need_tabs = 0;
                putchar(c);
            }
        } else {
            putchar(c);
        }
    }

    return 0;
}

$ ./a.out 
...
test    test    test    test
test    test    test    test
...
</code></pre>

Упражнение 1.21. Напишите программу entab, которая заменяла пустые строки, состоящие из одних пробелов, строками, содержащими минимальное кол-во табуляций и дополнительных пробелов - так чтобы заполнять то же пространство. Используйте те же параметры табуляции, что и в программе detab. Если для заполнения места до следующей границы табуляции требуется один пробел или один символ табуляции, то что следует предпочесть?

Упражнение 1.22. Напишите программу для сворачивания слишком длинных строк входного потока в две или более короткие строки после последнего не пустого символа, встречающийся после n-ым столбцом длинной строки. Постарайтесь, чтобы ваша программа обрабатывала очень длинные строки корректно, а также удаляла лишние пробелы и табуляции перед указанным столбцом.

Упражнение 1.23. Напишите программу для удаления всех комментариев из программы на C. Позаботьтесь о корректной обработке символьных констант и строк в двойных кавычках. Вложенные комментарии в C не допускаются

Упражнение 1.24. Напишите программу для выполнения примитивной синтаксической проверки программ на C, такие как непарные круглые, квадратные и фигурные скобки. Незабудь о одинарных и двойных кавычках, управляющих символах и комментариях.

# Глава 2. Типы данных

Упражнение 2.1. Напишите программу для определения диапазонов переменных типов char, short, int и long (как signed так и unsigned), путем вывода соответствующих значений из заголовочных файлов, а также с помощью непостредственного вычисления.


## Константы

<pre><code class="c">#define VAR 1       // константа целого типа
#define CHAR 'a'    // константа символьного типа

// Справочники
enum months {
    JAN = 1,
    FEB
};

int main(){

    printf("%d; %c; %d\n", VAR, CHAR, JAN);

    return 0;
}

$ ./a.out
...
1; a; 1
...
</code></pre> 

## Операции отношения и логические операции

Упражнение 2.2. Напишите цикл эквивалентный, не используя операции && и ||

<pre><code class="c">for (int i = 0; i <= N-1 && (c = getchar()) != EOF && c != '\n'; i++ )    
</code></pre>

## Преобразование типов

atoi - преобразует строку в целое число

<pre><code class="c">int atoi(char s[]);

int main(){

    char str[] = "456";
    int res;
    res = atoi(str);
    printf("%d\n", res);
    return 0;
}


// преобразует строку в целое число
int atoi(char s[]){
    int i, n = 0;
    for (i = 0; s[i] >= '0' && s[i] <= '9'; i++){
        n = n * 10 + (s[i] - '0');
    }
    return n;
}

...
456
[Finished in 0.1s]
...
</code></pre>

lower - преобразует символ в нижний регистр

<pre><code class="c">char lower(char);

int main(){
    char old_char = 'G';
    char new_char = lower(old_char);
    printf("%c\n", new_char);
    return 0;
}

// преобразует символ в нижний регистр
char lower(char c){
    if (c  >= 'A' && c <= 'Z')
        return c + 'a' - 'A';

    return c;
}

...
g
[Finished in 0.1s]
...
</code></pre>

